---
toc: content
order: 7
title: 双指针概念
group:
  title: 双指针
nav:
  title: 算法
  path: /algorithm
  order: 3
---

# 双指针

`双指针`是一种应用很广泛且基础的算法，严格来说双指针不是算法更像是一种思想。双指针中的`“指针”` 不仅仅是大家所熟知的`C/C++`里面的地址指针，还是索引、游标。本文将会简单介绍双指针及双指针的`四种常用模型`，用于双指针入门参考学习。

## 双指针的核心思想

`双指针是指在遍历对象时，使用两个或多个指针进行遍历及相应的操作。`大多用于数组操作，这利用了数组连序性的特点。双指针常用来降低算法的时间复杂度，因为使用两个指针可以避免多层循环。

## 双指针的关键点

- 指针的起始位置的选取
- 指针的移动方向
- 指针的移动速度  

**这三个关键点是双指针算法的核心也是难点，**

## 双指针的定义
`双指针`，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个`相同方向（快慢指针`）或者`相反方向（对撞指针）`的指针进行扫描，从而达到相应的目的。
换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。

## 对撞指针模型
`对撞指针`是指在`有序数组`中，将指向最左侧的索引定义为`左指针(left)`，最右侧的定义为`右指针(right)`，然后从两头向中间进行数组遍历。  
**对撞数组适用于有序数组，也就是说当你遇到题目给定有序数组时，应该第一时间想到用对撞指针解题。又称二分查找**

**求和**
```ts
function sum(arr,target){
  let left = 0,right = arr.length-1
  while(left<right){
    if(arr[left]+arr[right]>target){
      right--
    }else if(arr[left]+arr[right]<target){
      left++
    }else if(arr[left]+arr[right]==target){
      return [left,right]
    } 
  }
}

```
**数组反转**
```ts
function reverse(arr){
  let left = 0, right = arr.length-1
  while(left < right){
    [arr[left],arr[right]] = [arr[right],arr[left]]
    left++
    right--
  }
  return arr
}

```
## 快慢指针模型
快慢指针也是`双指针`，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为`快指针（fast）`和`慢指针（slow）`，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如`fast每次增长两个`，`slow每次增长一个`。  
- **注意** 快慢指针适用于链表。  
- **适合场景** 快慢指针适合处理链表类型的问题，尤其是涉及到链表的环、中间节点、倒数第k个节点等问题。在这些场景中，快慢指针可以有效地遍历链表，并且可以以不同的速度移动，从而找到需要的节点或者判断链表是否有环。  
- **应用场景** 例如，判断链表是否有环、找到链表的中间节点、判断链表的交点等问题。

**字符串压缩**
```ts
function compressString(S){
	let newS = '', i = 0, j = 0
	while(j < S.length - 1){
		if(S[j]!==S[j+1]){
			newS += S[i]+(j-i+1)
			i = j+1
		}
		j++
	}
	newS += S[i]+(j-i+1)
	return newS.length<S.length?S
}

```
